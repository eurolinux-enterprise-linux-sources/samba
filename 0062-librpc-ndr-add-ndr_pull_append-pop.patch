From d9e5f01948325906b1a3b6e9c1dc5edef8acfa78 Mon Sep 17 00:00:00 2001
From: Stefan Metzmacher <metze@samba.org>
Date: Sat, 21 Sep 2013 02:28:33 +0200
Subject: [PATCH 062/321] librpc/ndr: add ndr_pull_append/pop()

They can be used to parse a fragmented NDR byte stream.

ndr_pull_append() appends more data that can be processed
and ndr_pull_pop() removed already processed data.

This will be used to implement dcerpc pipes, where we can get
a verify large amount of pipe chunks, once we processed a chunk
we can forget about the related data, but we may need to keep some
bytes in order to get the alignment right.

Signed-off-by: Stefan Metzmacher <metze@samba.org>
Reviewed-by: Guenther Deschner <gd@samba.org>
(cherry picked from commit 7b5717058a7d7a93cda712efc7622a87d3980e48)
---
 librpc/ndr/libndr.h |   2 +
 librpc/ndr/ndr.c    | 105 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 107 insertions(+)

diff --git a/librpc/ndr/libndr.h b/librpc/ndr/libndr.h
index d32db1685be..f97577a7ff7 100644
--- a/librpc/ndr/libndr.h
+++ b/librpc/ndr/libndr.h
@@ -477,6 +477,8 @@ enum ndr_err_code ndr_pull_relative_ptr2(struct ndr_pull *ndr, const void *p);
 enum ndr_err_code ndr_pull_relative_ptr_short(struct ndr_pull *ndr, uint16_t *v);
 size_t ndr_align_size(uint32_t offset, size_t n);
 struct ndr_pull *ndr_pull_init_blob(const DATA_BLOB *blob, TALLOC_CTX *mem_ctx);
+enum ndr_err_code ndr_pull_append(struct ndr_pull *ndr, DATA_BLOB *blob);
+enum ndr_err_code ndr_pull_pop(struct ndr_pull *ndr);
 enum ndr_err_code ndr_pull_advance(struct ndr_pull *ndr, uint32_t size);
 struct ndr_push *ndr_push_init_ctx(TALLOC_CTX *mem_ctx);
 DATA_BLOB ndr_push_blob(struct ndr_push *ndr);
diff --git a/librpc/ndr/ndr.c b/librpc/ndr/ndr.c
index f7f366ea870..453b1c1ff76 100644
--- a/librpc/ndr/ndr.c
+++ b/librpc/ndr/ndr.c
@@ -77,6 +77,111 @@ _PUBLIC_ struct ndr_pull *ndr_pull_init_blob(const DATA_BLOB *blob, TALLOC_CTX *
 	return ndr;
 }
 
+_PUBLIC_ enum ndr_err_code ndr_pull_append(struct ndr_pull *ndr, DATA_BLOB *blob)
+{
+	enum ndr_err_code ndr_err;
+	DATA_BLOB b;
+	uint32_t append = 0;
+	bool ok;
+
+	if (blob->length == 0) {
+		return NDR_ERR_SUCCESS;
+	}
+
+	ndr_err = ndr_token_retrieve(&ndr->array_size_list, ndr, &append);
+	if (ndr_err == NDR_ERR_TOKEN) {
+		append = 0;
+		ndr_err = NDR_ERR_SUCCESS;
+	}
+	NDR_CHECK(ndr_err);
+
+	if (ndr->data_size == 0) {
+		ndr->data = NULL;
+		append = UINT32_MAX;
+	}
+
+	if (append == UINT32_MAX) {
+		/*
+		 * append == UINT32_MAX means that
+		 * ndr->data is either NULL or a valid
+		 * talloc child of ndr, which means
+		 * we can use data_blob_append() without
+		 * data_blob_talloc() of the existing callers data
+		 */
+		b = data_blob_const(ndr->data, ndr->data_size);
+	} else {
+		b = data_blob_talloc(ndr, ndr->data, ndr->data_size);
+		if (b.data == NULL) {
+			return ndr_pull_error(ndr, NDR_ERR_ALLOC, "%s", __location__);
+		}
+	}
+
+	ok = data_blob_append(ndr, &b, blob->data, blob->length);
+	if (!ok) {
+		return ndr_pull_error(ndr, NDR_ERR_ALLOC, "%s", __location__);
+	}
+
+	ndr->data = b.data;
+	ndr->data_size = b.length;
+
+	return ndr_token_store(ndr, &ndr->array_size_list, ndr, UINT32_MAX);
+}
+
+_PUBLIC_ enum ndr_err_code ndr_pull_pop(struct ndr_pull *ndr)
+{
+	uint32_t skip = 0;
+	uint32_t append = 0;
+
+	if (ndr->relative_base_offset != 0) {
+		return ndr_pull_error(ndr, NDR_ERR_RELATIVE,
+				      "%s", __location__);
+	}
+	if (ndr->relative_highest_offset != 0) {
+		return ndr_pull_error(ndr, NDR_ERR_RELATIVE,
+				      "%s", __location__);
+	}
+	if (ndr->relative_list != NULL) {
+		return ndr_pull_error(ndr, NDR_ERR_RELATIVE,
+				      "%s", __location__);
+	}
+	if (ndr->relative_base_list != NULL) {
+		return ndr_pull_error(ndr, NDR_ERR_RELATIVE,
+				      "%s", __location__);
+	}
+
+	/*
+	 * we need to keep up to 7 bytes
+	 * in order to get the aligment right.
+	 */
+	skip = ndr->offset & 0xFFFFFFF8;
+
+	if (skip == 0) {
+		return NDR_ERR_SUCCESS;
+	}
+
+	ndr->offset -= skip;
+	ndr->data_size -= skip;
+
+	append = ndr_token_peek(&ndr->array_size_list, ndr);
+	if (append != UINT32_MAX) {
+		/*
+		 * here we assume, that ndr->data is not a
+		 * talloc child of ndr.
+		 */
+		ndr->data += skip;
+		return NDR_ERR_SUCCESS;
+	}
+
+	memmove(ndr->data, ndr->data + skip, ndr->data_size);
+
+	ndr->data = talloc_realloc(ndr, ndr->data, uint8_t, ndr->data_size);
+	if (ndr->data_size != 0 && ndr->data == NULL) {
+		return ndr_pull_error(ndr, NDR_ERR_ALLOC, "%s", __location__);
+	}
+
+	return NDR_ERR_SUCCESS;
+}
+
 /*
   advance by 'size' bytes
 */
-- 
2.14.3

