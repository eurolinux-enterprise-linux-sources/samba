From 4c2a695a58192d08b18065334370b36e101dfa56 Mon Sep 17 00:00:00 2001
From: David Disseldorp <ddiss@samba.org>
Date: Thu, 18 Dec 2014 18:23:11 +0100
Subject: [PATCH 267/321] printing: add nt_printer_guid_retrieve() helper

This function connects to the domain controller and retrieves the
GUID for the corresponding printer DN.

BUG: https://bugzilla.samba.org/show_bug.cgi?id=11018

Pair-programmed-with: Andreas Schneider <asn@samba.org>
Signed-off-by: David Disseldorp <ddiss@samba.org>
Signed-off-by: Andreas Schneider <asn@samba.org>
Reviewed-by: Guenther Deschner <gd@samba.org>
(cherry picked from commit 38dbd054dc331a441b10fdebbdb4bd0fc51cfc0a)
---
 source3/include/nt_printing.h      |  3 ++
 source3/printing/nt_printing_ads.c | 58 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 61 insertions(+)

diff --git a/source3/include/nt_printing.h b/source3/include/nt_printing.h
index cdbad875ed3..67a05227066 100644
--- a/source3/include/nt_printing.h
+++ b/source3/include/nt_printing.h
@@ -132,6 +132,9 @@ bool print_access_check(const struct auth_serversupplied_info *server_info,
 			struct messaging_context *msg_ctx, int snum,
 			int access_type);
 
+WERROR nt_printer_guid_retrieve(TALLOC_CTX *mem_ctx, const char *printer,
+				struct GUID *pguid);
+
 WERROR nt_printer_guid_get(TALLOC_CTX *mem_ctx,
 			   const struct auth_serversupplied_info *server_info,
 			   struct messaging_context *msg_ctx,
diff --git a/source3/printing/nt_printing_ads.c b/source3/printing/nt_printing_ads.c
index 25e1ab6e972..6fa4bfc23da 100644
--- a/source3/printing/nt_printing_ads.c
+++ b/source3/printing/nt_printing_ads.c
@@ -209,6 +209,58 @@ static WERROR nt_printer_guid_retrieve_internal(ADS_STRUCT *ads,
 	return WERR_OK;
 }
 
+WERROR nt_printer_guid_retrieve(TALLOC_CTX *mem_ctx, const char *printer,
+				struct GUID *pguid)
+{
+	ADS_STRUCT *ads = NULL;
+	char *old_krb5ccname = NULL;
+	char *printer_dn;
+	WERROR result;
+	ADS_STATUS ads_status;
+	TALLOC_CTX *tmp_ctx;
+
+	tmp_ctx = talloc_new(mem_ctx);
+	if (tmp_ctx == NULL) {
+		return WERR_NOMEM;
+	}
+
+	ads = ads_init(lp_realm(), lp_workgroup(), NULL);
+	if (ads == NULL) {
+		result = WERR_SERVER_UNAVAILABLE;
+		goto out;
+	}
+
+	old_krb5ccname = getenv(KRB5_ENV_CCNAME);
+	setenv(KRB5_ENV_CCNAME, "MEMORY:prtpub_cache", 1);
+	SAFE_FREE(ads->auth.password);
+	ads->auth.password = secrets_fetch_machine_password(lp_workgroup(),
+							    NULL, NULL);
+
+	ads_status = ads_connect(ads);
+	if (!ADS_ERR_OK(ads_status)) {
+		DEBUG(3, ("ads_connect failed: %s\n", ads_errstr(ads_status)));
+		result = WERR_ACCESS_DENIED;
+		goto out;
+	}
+
+	result = nt_printer_dn_lookup(tmp_ctx, ads, printer, &printer_dn);
+	if (!W_ERROR_IS_OK(result)) {
+		goto out;
+	}
+
+	result = nt_printer_guid_retrieve_internal(ads, printer_dn, pguid);
+out:
+	TALLOC_FREE(tmp_ctx);
+	ads_destroy(&ads);
+	ads_kdestroy("MEMORY:prtpub_cache");
+	unsetenv(KRB5_ENV_CCNAME);
+	if (old_krb5ccname != NULL) {
+		setenv(KRB5_ENV_CCNAME, old_krb5ccname, 0);
+	}
+
+	return result;
+}
+
 WERROR nt_printer_guid_get(TALLOC_CTX *mem_ctx,
 			   const struct auth_serversupplied_info *session_info,
 			   struct messaging_context *msg_ctx,
@@ -652,6 +704,12 @@ bool is_printer_published(TALLOC_CTX *mem_ctx,
 	return true;
 }
 #else
+WERROR nt_printer_guid_retrieve(TALLOC_CTX *mem_ctx, const char *printer,
+				struct GUID *pguid)
+{
+	return WERR_NOT_SUPPORTED;
+}
+
 WERROR nt_printer_guid_get(TALLOC_CTX *mem_ctx,
 			   const struct auth_serversupplied_info *session_info,
 			   struct messaging_context *msg_ctx,
-- 
2.14.3

